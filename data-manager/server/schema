
-- Copyright (c) 2008-2010, Regents of the University of Colorado.
-- This work was supported by NASA contracts NNJ05HE10G, NNC06CB40C, and
-- NNC07CB47C.


-- 
-- Note: This validates rows for uniqueness as appropriate, but does no
--       validation of column contents beyond that.  For example, it'll
--       happily let you insert a node named "$!@##$%///\\\"
-- 


-- this table has one row for each distinct HAB we've ever seen
CREATE TABLE Hardware_Abstractors (
    Key INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,  -- row index
    HAB_Type VARCHAR(255) NOT NULL,       
    HAB_ID VARCHAR(255) NOT NULL,
    UNIQUE (HAB_Type, HAB_ID)
);
CREATE INDEX HAB_Type_Index ON Hardware_Abstractors(HAB_Type);
CREATE INDEX HAB_ID_Index ON Hardware_Abstractors(HAB_ID);


-- this table has one row for each distinct Node we've ever seen
CREATE TABLE Nodes (
    Key     INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,  -- row index
    GUID    BLOB,                                        --bottom 64 bits of SHA1 of all resources' metadata
    HAB_Key INTEGER NOT NULL REFERENCES Hardware_Abstractor(Key), -- Key of the HAB that this Node belongs to
    Node_ID VARCHAR(255) NOT NULL,
    UNIQUE (GUID)
);
CREATE INDEX HAB_Key_Index ON Nodes(HAB_Key);
CREATE INDEX Node_ID_Index ON Nodes(Node_ID);
CREATE INDEX GUID_ID_Index ON Nodes(GUID);


-- this table has one row for each Data Type we support
CREATE TABLE Resource_Data_Types (
    Key INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,  -- row index
    Data_Type VARCHAR(255) NOT NULL,
    UNIQUE (Data_Type)
);
CREATE INDEX Data_Type_Index ON Resource_Data_Types(Data_Type);
INSERT INTO Resource_Data_Types VALUES (NULL, 'binary');
INSERT INTO Resource_Data_Types VALUES (NULL, 'uint8');
INSERT INTO Resource_Data_Types VALUES (NULL, 'int8');
INSERT INTO Resource_Data_Types VALUES (NULL, 'uint16');
INSERT INTO Resource_Data_Types VALUES (NULL, 'int16');
INSERT INTO Resource_Data_Types VALUES (NULL, 'uint32');
INSERT INTO Resource_Data_Types VALUES (NULL, 'int32');
INSERT INTO Resource_Data_Types VALUES (NULL, 'float');
INSERT INTO Resource_Data_Types VALUES (NULL, 'double');
INSERT INTO Resource_Data_Types VALUES (NULL, 'string');


-- this table has one row for each Flavor we support
CREATE TABLE Resource_Flavors (
    Key INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,  -- row index
    Flavor VARCHAR(255) NOT NULL,
    UNIQUE (Flavor)
);
CREATE INDEX Flavor_Index ON Resource_Flavors(Flavor);
INSERT INTO Resource_Flavors VALUES (NULL, 'sensor');
INSERT INTO Resource_Flavors VALUES (NULL, 'actuator');
INSERT INTO Resource_Flavors VALUES (NULL, 'parameter');


-- this table has one row for each BDM that has synced to/from, including the local BDM
CREATE TABLE BDMs (
    Key INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,  -- row index
    BDM_ID VARCHAR(255) NOT NULL,
    -- NOTE: Once a bundle is sent, these values are updated, and the bundle is 
    -- inserted into the 'Sync_*_Bundle_Outstatnding' table, and later removed
    -- once it has been confirmed.
    Last_Sync INTEGER REFERENCES Events(seq), --Seq of the last successfully sent event
    UNIQUE (BDM_ID)
);
CREATE INDEX BDM_ID_Index ON BDMs(BDM_ID);


-- this table has one row for each distinct resource we've ever seen
-- this is the resource metadata
CREATE TABLE Resources (
    Key BLOB PRIMARY KEY NOT NULL,                   -- bottom 64 bits of SHA1 of metadata
    Node_Key INTEGER NOT NULL REFERENCES Nodes(Key), -- key of  Node that this Resource belongs to
    Resource_ID VARCHAR(255) NOT NULL,
    Data_Type_Key INTEGER NOT NULL,
    Flavor_Key INTEGER NOT NULL,
    UNIQUE (Key),
    UNIQUE (Node_Key, Resource_ID, Data_Type_Key, Flavor_Key)
);
CREATE INDEX Node_Key_Index ON Resources(Node_Key);
CREATE INDEX Resource_ID_Index ON Resources(Resource_ID);


-- one row for each Datapoint we've ever seen
-- this is the resource data
CREATE TABLE Datapoints (
    Key INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,  -- row index
    Resource_Key INTEGER NOT NULL REFERENCES Resources (Key),  -- the row index in the Resources table of the Resource that this Datapoint belongs to
    Value INTEGER NOT NULL,                          -- taking advantage of sqlite's manifest typing
    Timestamp_Sec  INTEGER NOT NULL,
    Timestamp_Usec INTEGER NOT NULL,
    UNIQUE (Resource_Key, Value, Timestamp_Sec, Timestamp_Usec)
);
CREATE INDEX Resource_Key_Index ON Datapoints(Resource_Key);
CREATE INDEX Timestamp_Sec_Index ON Datapoints(Timestamp_Sec);

-- Events table
--
-- This table records the time and sequence of all events
-- Sync'd events will have another recoding_bdm
-- Each event records one type of information. 
--
-- This is a single table for all events to make sequencing more simple 
-- in sqlite3, which doesn't provide a nextval()/curval() feature
CREATE TABLE Events (
    seq        INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,   -- sequence number
    timestamp_sec  INTEGER,                                  -- Time this event was recorded
    timestamp_usec INTEGER,                                  -- Time this event was recorded
    recording_bdm INTEGER REFERENCES BDMs(Key),
    islost     BOOLEAN,                                      -- True if "lost" event, False if "new".
    -- One of the following will be not null
    hab        INTEGER REFERENCES Hardware_Abstractors(Key), 
    node       INTEGER REFERENCES Nodes(Key),
    datapoint  INTEGER REFERENCES Datapoints(Key),
    UNIQUE (timestamp_sec,timestamp_usec,recording_bdm,islost,hab,node,datapoint)
);
CREATE INDEX time_Index ON Events(timestamp_sec, timestamp_usec);
CREATE INDEX bdm_Index ON Events(recording_bdm);
CREATE INDEX hab_Index ON Events(hab);
CREATE INDEX node_Index ON Events(node);
CREATE INDEX datapoint_Index ON Events(datapoint);

